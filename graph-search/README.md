# 그래프 탐색

그래프의 각 노드를 한번씩 방문하는 것을 트리에서와 마찬가지로 순회라고 한다.

그래프 순회에는 깊이 우선탐색(depth first search)와 너비 우선 탐색(breadth first search)의 두가지 방법이 있다

## 깊이 우선 탐색(DFS)

- 출발점 v를 방문하는 것으로 시작한다
- v에 인접하고 아직 방문하지 않은 정점 w를 선택하여 w를 출발점으로 다시 깊이 우선탐색을 시작한다
- 만약 인접한 모든 정점들이 모두 방문한 정점인 경우
  - 가장 최근에 방문했던 정점 중에서, 방문하지 않은 정점 w를 가진 정점을 선택
  - 정점 w로부터 다시 깊이 우선탐색을 한다
- 미방문 정점이 바닥나면 탐색을 종료한다

### 순환 호출 이용

```go
func DFS(visited []bool, v int) {
    w int
    visited[v] = true
    for v에 인접한 모든 노드 w {
        if !visited[w] {
            DFS(visited, w)
        }
    }
}
```

### 스택 이용

```go
func DFS(int v) {
    var n, w int
    visited := []bool{}
    stack := NewStack()
    stack.Push(v)
    visited[v] = true
    for (n = stack.Pop()) >= 0 {
        visited[n] = true
        for n에 인접한 모든 노드w {
            if !visited[w] {
                stack.Push(w)
            }
        }
    }
}
```

## 너비 우선 탐색(BFS)

- 출발점 v를 방문하는 것으로 시작
- v에 인접한 정점 w를 모두 방문한 후, 다시 w에 인접한 방문하지 않은 정점들을 차례로 방문함
- 이 과정을 모든 정점을 한 번씩 방문할 때까지 반복함

너비 우선탐색은 인접 정점을 모두 방문하기 때문에 스택대신 큐를 사용한다.

- 한 정점을 방문하면 다음으로 인접 정점을 방문해야 하므로 이때 인접정점을 모두 큐에 차례로 저장한다
- 저장한 순서대로 꺼내서 계속 방문한다
- 매번 방문하기 전에 그 정점의 인접 정점을 모두 큐에 저장한다

### 큐 이용

```go
func BFS(v int) {
    w int
    queue := NewQueue()
    visited := []bool{}

    visited[v] = true
    queue.Add(v)

    for !queue.IsEmpty() {
        v = queue.Remove()
        for v에 인접한 모든 노드 w {
            if !visited[w] {
                queue.Add(w)
                visited[w] = true
            }
        }
    }
}
```

## 최소 신장 트리

사이클이 없는 단순 그래프가 트리이다.
트리는 그래프이기는 하지만 루트를 가지기 때문에 계층 개념이 있고,
사이클이 없어서 한 정점에서 다른 정점으로 가는 경로가 유일하다.

때로는 주어진 그래프에서 트리를 만들어내는 일이 중요하다.

그래프 G의 **모든 정점**과 간선의 일부(또는 전부)를 포함하는 트리를 신장 트리(spanning tree)라고 한다.

그래프의 G 부분 그래프 중에서 간선의 수가 가장 작은 것을 G의 최소 부분 그래프라고 한다.
그래프 G가 n개의 정점을 가질 때 정점들이 모두 연결되려면 최소 n-1개의 간선이 필요하다.

즉, n-1의 간선으로 구성한 것이 최소 신장 트리이다

깊이 우선 탐색 알고리즘을 이용하여 만든 신장 트리를 깊이 우선 신장 트리라 하고,
너비 우선 탐색 알고리즘을 이용하여 만든 신장 트리를 너비 우선 신장 트리라고 한다.

신장 트리를 실제로 응용할 때는 각 간선에 가중치가 부여되어 있는 경우가 많다.
가능하면 가중치가 적은 간선을 선택하여 구성한 신장트리를 최소 비용 신장 트리라고 한다.

최소 비용 신장 트리를 구하는 몇 가지 방법은 다음과 같다.
단, 알고리즘이 항상 최저비용 신장트리를 구하는 것을 보장하지는 않는다.

> 프림 알고리즘, 크루스컬 알고리즘, 솔린 알고리즘

### 프림 알고리즘

n개의 정점을 갖는 연결 그래프 G에 대한 최소 비용 신장 트리 T를 구하는 프림 알고리즘은 다음과 같다

```go
func prim() {
    T := {}
    W := {}
    E로부터 최소 비용인 간선 {v, w}를 선택
    for T는 n-1개 이하의 간선을 포함 && E는 공집합이 아님 {
        E에서 간선 {v, w}를 제거
        if {v, w}가 T내에서 사이클을 생성 안함 {
            T = T ∪ {{v, w}} // 선택한 간선 추가
            W = W ∪ {{v, w}} // 선택한 정점 추가
        } else {
            간선 {v, w} 버림
        }
        E로부터 W내의 정점과 최소 비용으로 연결된 간선 {v, w}를 선택
    }
}
```

### 크루스컬 알고리즘

크루스컬 알고리즘은 남은 간선 중에서 무조건 최소 비용인 간선을 선택한 후 사이클을 형성하지 않으면 그 간선을 선택한다

따라서 프림 알고리즘과는 다르게 중간과정에 있는 T는 하나의 트리가 아니고 여러 개의 분리된 트리: 숲일 수 있다.
하지만 크루스컬 알고리즘의 최종결과는 최소 비용 신장 트리가 된다.

```go
func kruskal() {
    T := {}
    for T가 n-1개 보다 적은 간선을 포함하고 E가 공집합이 아님 {
        E로부터 최소 비용인 간선 {v, w}를 선택
        E에서 간선 {v, w}를 제거
        if {v, w}가 T내에서 사이클을 생성 안 함 {
            T = T ∪ {{v, w}}
        } else {
          간선 {v, w}를 버림
        }
    }
}
```

### 솔린 알고리즘

프림 알고리즘 및 크루스컬 알고리즘은 각 단계마다 하나의 간선을 선택한다.
이와 달리 솔린 알고리즘은 다수의 간선을 선택한다.

- 솔린 알고리즘은 (간선이 하나도 없고) 그래프의 모든 정점들로 구성된 숲에서 시작한다
- 단계가 거듭되면서 숲 내의 트리들을 최소 비용을 갖는 간선으로 연결한다
- 이 과정을 남은 간선이 없거나 완전한 트리가 생성될 때까지 반복하면 신장트리를 얻는다

```go
func sollin() {
    E := { 주어진 그래프의 간선 집합 }
    F := { 그래프의 모든 정점들로 구성된 간선이 없는 숲 }
    T := {}

    for T는 완전한 하나의 트리가 아니고 E는 공집합이 아님 {
        for F 내의 각각의 트리 T에 대하여 {
            T와 다른 트리를 연결하는 E의 간선 중에서 최소비용 간선 {v, w}를 선택
            T = T ∪ {{v, w}}
            E에서 간선 {v, w}를 제거
        }
        T에 새로 추가된 간선을 포함하여 F를 수정
    }
}
```
