# B Tree

| Algorithm | Average | Worst case |
| --- | --- | --- |
| Space | O(n) | O(n) |
| Search | O(log n) | O(log n) |
| Insert | O(log n) | O(log n) |
| Delete | O(log n) | O(log n) |

노드의 가지 개수를 늘리는 것만이 m-way 탐색트리의 성능을 향상시키는 유일한 방법은 아니다.
이진 탐색트리와 마찬가지로 트리의 균형을 유지하며 탐색 성능을 개선할 수 있다.

다음 조건을 만족하는것을 차수 m인 B 트리라고 한다.
이 트리는 인덱스 구조를 구현하는 데 가장 일반적으로 사용된다.

- (최대 차수) 모든 노드는 최대 m개의 자식노드를 갖는다
- (최소 차수) 루트와 leaf 노드를 제외한 트리의 각 노드는 최소 `ceil(m/2)`개의 서브트리를 갖는다
  - 3차수 트리인경우 `ceil(3/2) = 2`이고 최소 두 개의 서브트리가 필요하다
- 노드의 key 개수는 `차수 - 1`이다
- 트리의 루트는 최소한 2개 또는 0개의 서브트리를 갖는다
- 트리의 모든 leaf 노드는 같은 레벨에 있어 균형이 잡히도록 만든다

## B Tree: 삽입

B 트리에 키를 삽입하는 알고리즘은 다음과 같다

- 삽입할 위치를 찾기 위해 노드의 키값을 좌에서 우로 탐색한다
  - B 트리에서 모든 노드는 leaf에서 삽입이 개시된다
- 노드에 빈자리가 있으면 삽입 후 종료한다
- 노드가 꽉 찼으면 노드를 두 개로 분리하고 키와 포인터를 새 노드에 반씩 할당한다
  - leaf 노드 키값 + 삽입 노드 키값 중 중간값을 선택한다
  - 선택된 중간값보다 작은 키값을 갖는 것은 왼쪽 노드에 넣고 큰 것은 오른쪽 노드에 넣는다
  - 중간값을 가지는 노드의 키와 포인터를 부모 노드에 삽입한다
  - 만일 부모 노드가 루트 노드이면 두 노드를 가리키도록(자식노드가 되도록) 수정한다

## B Tree: 삭제

B 트리형태를 유지하기 위해서는 어떤 노드가 정해진 개수의 키를 가져와야 한다.
따라서 삭제 결과 개수가 부족하면 그 노드를 다른 노드와 묶어야 한다.

- 삭제할 키 값을 포함한 노드를 찾는다

- leaf 노드에서 삭제하는 경우
  - 노드에서 키 값을 삭제한다
  - 필요하면 재배열 한다

- 내부 노드에서 삭제하는 경우
  > 내부 노드 키값은 하위 노드에 대한 중간값이기 때문에 삭제 시 대체할 수 있는 값을 찾아야 한다. 보통 왼쪽 서브트리의 가장 큰 키값 또는 오른쪽 서브트리의 가장 작은 키 값으로 대체할 수 있다. 이들은 모두 leaf에 위치한다
  - 새로운 기준값(삭제된 자리에 올 키값)을 선택하여 해당 (leaf)노드에서 삭제하고 그 값을 현재 키값을 삭제한 자리로 옮긴다
  - 기준값으로 대체하기 위해 키를 삭제한 leaf 노드가 정해진 개수의 기값을 갖지 않으면 트리를 재배열 한다

### 재배열

- 키값이 부족한 노드의 오른쪽 형제가 존재하고 키가 정해진 개수보다 많다면 왼쪽으로 회전한다
  - 부모 노드의 기준(키)값을 개수가 부족한 노드의 끝으로 이동한다(기준값을 한 단계 아래로 내려 개수를 채운다)
  - 부모 노드의 기준값을 오른쪽 형제의 첫 번째 키로 수정해 균형을 맞춘다

- 키값이 부족한 노드의 왼쪽 형제가 존재하고 키가 정해진 개수보다 많다면 오른쪽으로 회전한다
  - 부모 노드의 기준(키)값을 개수가 부족한 노드의 끝으로 이동한다(기준값을 한 단계 아래로 내려 개수를 채운다)
  - 부모 노드의 기준값을 왼쪽 형제의 첫 번째 키로 수정해 균형을 맞춘다

- 좌우 형제가 최소 개수의 키를 가지고 있다면, 좌우 형제를 합친다
  - 부모 노드의 기준(키)값을 왼쪽 노드의 마지막에 복사한다
  - 오른쪽 노드의 모든 키값을 왼쪽 노드로 옮긴다(왼쪽 노드가 최대 개수의 키를 갖는다)
  - 키를 갖지 않는 오른쪽 노드는 삭제한다
  - 부모 노드가 루트이면서 키를 더 이상 갖지 않으면 합쳐진 노드가 새로운 루트가 된다
  - 그렇지 않고 부모 노드의 키 개수가 정해진 개수보다 작으면 부모 노드를 재배열한다

## B* Tree / B+ Tree

### B* 트리

노드의 2/3 이상이 차야 하는 B 트리를 B* 트리라고 한다.

B* 트리면 노드가 꽉차면 분리하지 않고 키와 포인터를 재배치하여 다른 형제 노드로 옮긴다.
이는 삽입/삭제시 발생하는 노드 분리를 줄이기 위함이다.

- 공집합이거나 높이가 1 이상인 m-way 탐색 트리이다
- 루트 노드는 2개 이상 `floor((2m-2)/3) + 1`개 이하의 자식 노드를 갖는다
- 내부 노드는 최소한 `ceil((2m-1)/3)`개의 자식 노드를 갖는다
- 모든 leaf 노드는 동일한 레벨에 놓인다
- 포인터가 k개인 leaf 노드가 아닌 노드는 k-1개의 키를 갖는다(루트노드 포함)

#### B* 트리: 삽입

B* 트리는 분리를 하는 대신 가능하다면 형제 노드로 키값을 이동한다.

전체 키 개수의 절반은 왼쪽 서브 노드에 넣고 중간 키값은 부모노드에 기준값으로 배치하고,
나머지 절반은 오른쪽 서브 노드에 배치한다.

만약 오른쪽 서브 노드(형제 노드) 역시 차 있는 경우 두 개의 노드를 세 개의 노드로 분리한다.
B* 트리는 노드의 2/3를 채워야 하기 때문이다.

### B+ 트리

단순 연결 리스트는 저장된 데이터를 순차 처리하는데는 적합하지만 특정 값을 탐색하는경우 적합하지 않다.
데이터를 탐색 트리로 구성하면 빠르게 탐색할 수 있지만 전체 데이터를 차례로 처리하기는 어렵다.

B+ 트리는 B 트리와 같이 각 노드의 키값이 적어도 1/2이 차야 하는 점은 같다.
하지만 leaf 노드를 순차적으로 연결하는 포인터 집합이 있다는 점에서 다르다.

B+ 트리는 leaf 노드의 마지막 포인터를 다음 키값을 갖는 노드를 가리킨다.
따라서 순차처리를 할 때는 이 포인터를 이용해서 차례로 다음 데이터에 접근해서 처리할 수 있다.

B+ 트리에서는 모든 키값이 leaf 노드에 있고 그 키값에 대응하는 실제 데이터에 대한 주소를 leaf노드만이 가지고 있다.
따라서 직접 탐색은 leaf에 도달해야 종료된다.
찾고자 하는 키를 내부 노드에서 찾는다 해도 leaf에 도달할 때까지 계속 내려가야 한다.

#### B+ 트리: 삽입/삭제

B+ 트리에 새로운 키값을 삽입하는 과정은 B 트리의 경우와 거의 같다.
leaf 노드가 두 개의 노드로 분리될 때는 키값 순서에 따라 배치하고 중간 키값은 부모 노드에 올려놓는다.
그리고 새 노드는 순서에 맞게 leaf노드에 삽입한다.

B+ 트리에서 키값을 삭제하는 과정은 다른 트리에 비해 비교적 쉽다.
키값을 leaf 노드에서 삭제할 때, 트리의 내부 노드에서도 삭제할 필요가 없다.
왜냐하면 키 값이 직접 탐색을 위해 쓰이기 때문이다.
