# Heap

피라미드 모양으로 쌓아올린 더미를 힙이라 하고,
힙 자료구조는 쌓아놓은 더미에서 가장 위에 있는 것을 꺼내는 것이다.

## 힙 추상자료형

- 힙 객체: **부분적으로 정렬된 포화 이진트리로 부모 노드는 자식노드보다 우선순위가 높다**
- 인터페이스
  - `insert(element)` ::= 힙에 데이터 삽입 `(O(logn))`
  - `remove()` ::= 힙의 루트에서 데이터 삭제 `(O(logn))`
  - `peek()` ::= 힙의 루트에서 데이터 읽기
  - `isEmpty()` ::= 힙이 비었는지 확인
  - `size()` ::= 힙에 저장한 데이터 개수 확인

최소 힙은 루트가 최소값이고 최대힙은 루트가 최대값이다.
최소힙은 트리의 모든 노드가 자식 노드보다 작은값을 갖고, 최대힙은 트리의 모든 노드가 자식 노드보다 큰 값을 갖는다.

힙이 부분적으로 정렬되었다는 것은 트리 전체가 루트로부터 차례대로 배치되지는 않았다는 뜻이다.
즉, 트리의 레벨에 따라 데이터가 순서를 갖지는 않는다.

## 최소힙 구현

힙은 포화 이진트리이기 때문에 기억장소의 낭비가 적다.
따라서 배열로 구현한다. 각 레벨의 크기는 `2^n`이다.

- [heap.go](./heap.go)
- [heap_test.go](./heap_test.go)

### 힙의 삭제연산

- 힙을 삭제하는 메소드는 루트 노드를 삭제하는 것으로 시작한다
- 그리고 임시로 힙의 마지막 원소를 루트로 옮긴다(포화 이진트리이므로)
- 임시 루트값과 자식 노드의 값을 비교한다(부모노드)
  - 만일 루트 값이 자식노드보다 작으면 삭제 연산을 끝낸다
  - 그렇지 않다면 가장 작은 값을 갖는 자식노드와 임시 루트를 교체한다
    - 자식과 교체한 임시루트 노드를 자식노드와 비교한다
    - 만일 임시루트 노드 값이 자식노드보다 작으면 삭제연산을 끝내고, 그렇지 않다면 마지막 레벨까지 반복진행한다

### 힙의 삽입연산

- 삽입 후 포화 이진 트리를 유지하기 위해서 우선 트리를 확장해야 한다. 따라서 힙 크기를 하나 증가시킨다
- 해당 위치에 삽입 데이터를 저장한다
- 삽입 데이터와 부모 노드 값을 비교한다
  - 삽입 데이터가 더 크다면 삽입연산을 종료한다
  - 삽입 데이터가 더 작다면 부모노드와 위치를 교체한다
    - 루트 노드까지 크기 비교와 위치교체를 진행하고 비교시 삽입 데이터가 더 큰경우 삽입연산을 종료한다

## 우선순위 큐(Priority Queue)

우선순위 큐는 다양한 방법으로 구현할 수 있다.
배열이나 LinkedList를 이용해서 원소를 꺼낼때마다 모든값을 순회하여 우선순위가 가장 높은 값을 찾을 수 있다.

하지만 Heap 자료구조를 사용하면 보다 빠르고 간단하게 우선순위 큐를 구현할 수 있다.

### 우선순위 큐 구현

- priority_queue.go
- priority_queue_test.go
