# Binary Search Tree

| Algorithm | Average | Worst case |
| --- | --- | --- |
| Space | O(n) | O(n) |
| Search | O(log n) | O(n) |
| Insert | O(log n) | O(n) |
| Delete | O(log n) | O(n) |

이진 탐색 트리는 특정 데이터가 있는지 검색하고, 노드를 자주 삽입/삭제 하는 문제에 효과적이다
하지만, 경사트리의 경우 효율이 좋지 않다.

노드 Vi의 키를 Ki라 할 때 각 노드 Vi 가 다음을 만족하는 이진트리를 이진 탐색 트리라 한다

- Vi의 왼쪽 서브트리에 있는 모든 노드의 키값은 Vi의 키값보다 작다
- Vi의 오른쪽 서브트리에 있는 모든 노드의 키값은 Vi의 키값보다 크다

순서가 같은 키에 대해 BS 트리가 유일하게 존재하지는 않는다

> 일반적인 탐색트리의 응용에서 키값은 보통 문자열이다(정렬과 빠른 검색)

## 트리 순회

BS 트리는 전위/중위/후위 순회로 모든 정점을 차례로 순회할 수 있고 트리내의 특정 정점을 탐색할 수도 있다.

일반적으로 중위 순회 알고리즘이 전위 순회나 후위 순회보다 순환 호출로 구현하기 쉽다.

일반적으로 전위 순회나 후위 순회 방법은 BS트리에서 잘 사용하지 않는다.

## 트리 탐색

BS 트리에서는 어떤 키 값을 갖는 노드가 그 트리에 있는지 빠르게 확인할 수 있다.

노드 Vi의 키를 Ki라 할 때 키값이 K인 노드를 찾는 과정은 다음과 같다

- 트리가 비어 있다면 탐색 실패, 아니면 K와 현재 루트 노드의 키값 Ki를 비교한다
- `K = Ki`: 탐색 성공, 이때 찾은 정점은 Vi이다
- `K < Ki`: Vi의 왼쪽 서브트리를 탐색한다
- `K > Ki`: Vi의 오른쪽 서브트리를 탐색한다

## 트리 삽입/삭제

이진 탐색 트리에서 새 노드는 항상 leaf로 삽입한다.

- 트리가 비어 있으면 키 K를 가지는 노드를 삽입한다
- 트리가 비어있지 않으면 K와 현재 루트 노드의 키 Ki를 비교한다
  - `K = Ki`: 멈춘다
  - `K < Ki`: Vi의 왼쪽 서브트리에 삽입해야 하므로 Vi = Vi.left로 하고 처음부터 진행한다
  - `K > Ki`: Vi의 오른쪽 서브트리에 삽입해야 하므로 Vi = Vi.right로 하고 처음부터 진행한다

노드를 삭제하려면 자식노드를 처리해야 한다

- 자식이 하나인 노드(한쪽 서브트리가 null)를 삭제하는 경우
  - 삭제한 노드를 가리키던 포인터에 해당 노드의 null이 아닌 서브트리 루트를 할당
- 자식이 둘인 노드를 삭제하는 경우
  - 삭제한 노드를 가리키던 부모의 포인터에 다음 값을 할당한다
  - 왼쪽 서브트리의 가장 큰 값 또는 오른쪽 서브트리의 가장 작은 값을 지닌 노드 포인터
  - 새로 할당한 값에 삭제한 노드의 left, right 포인터를 할당한다

## 이진 탐색 트리 구현

- [bs_tree.go](./bs_tree.go)
- [bs_tree_test.go](./bs_tree_test.go)
