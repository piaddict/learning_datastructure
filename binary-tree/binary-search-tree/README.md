# 이진 탐색 트리 (BS 트리)

이진 탐색 트리는 특정 데이터가 있는지 검색하고, 노드를 자주 삽입/삭제 하는 문제에 효과적이다

노드 Vi의 키를 Ki라 할 때 각 노드 Vi 가 다음을 만족하는 이진트리를 이진 탐색 트리라 한다

- Vi의 왼쪽 서브트리에 있는 모든 노드의 키값은 Vi의 키값보다 작다
- Vi의 오른쪽 서브트리에 있는 모든 노드의 키값은 Vi의 키값보다 크다

순서가 같은 키에 대해 BS 트리가 유일하게 존재하지는 않는다

일반적인 탐색트리의 응용에서 키값은 보통 문자열이다(정렬과 빠른 검색)

## 트리 순회

BS 트리는 전위/중위/후위 순회로 모든 정점을 차례로 순회할 수 있고 트리내의 특정 정점을 탐색할 수도 있다.

일반적으로 중위 순회 알고리즘이 전위 순회나 후위 순회보다 순환 호출로 구현하기 쉽다.

일반적으로 전위 순회나 후위 순회 방법은 BS트리에서 잘 사용하지 않는다.

## 트리 탐색

BS 트리에서는 어떤 키 값을 갖는 노드가 그 트리에 있는지 빠르게 확인할 수 있다.

노드 Vi의 키를 Ki라 할 때 키값이 K인 노드를 찾는 과정은 다음과 같다

- 트리가 비어 있다면 탐색 실패, 아니면 K와 현재 루트 노드의 키값 Ki를 비교한다
- `K = Ki`: 탐색 성공, 이때 찾은 정점은 Vi이다
- `K < Ki`: Vi의 왼쪽 서브트리를 탐색한다
- `K > Ki`: Vi의 오른쪽 서브트리를 탐색한다

## 트리 삽입/삭제

이진 탐색 트리에서 새 노드는 항상 leaf로 삽입한다.

- 트리가 비어 있으면 키 K를 가지는 노드를 삽입한다
- 트리가 비어있지 않으면 K와 현재 루트 노드의 키 Ki를 비교한다
  - `K = Ki`: 멈춘다
  - `K < Ki`: Vi의 왼쪽 서브트리에 삽입해야 하므로 Vi = Vi.left로 하고 처음부터 진행한다
  - `K > Ki`: Vi의 오른쪽 서브트리에 삽입해야 하므로 Vi = Vi.right로 하고 처음부터 진행한다

노드를 삭제하려면 자식노드를 처리해야 한다

- 자식이 하나인 노드(한쪽 서브트리가 null)를 삭제하는 경우
  - 삭제한 노드를 가리키던 포인터에 해당 노드의 null이 아닌 서브트리 루트를 할당
- 자식이 둘인 노드를 삭제하는 경우
  - 삭제한 노드를 가리키던 부모의 포인터에 다음 값을 할당한다
  - 왼쪽 서브트리의 가장 큰 값 또는 오른쪽 서브트리의 가장 작은 값을 지닌 노드 포인터
  - 새로 할당한 값에 삭제한 노드의 left, right 포인터를 할당한다

## 자가 균형 이진 탐색 트리 구현

자가 균형 이진 탐색 트리는 삽입과 삭제가 일어나는 경우에 자동으로 균형의 차이를 작게 유지하는 노드 기반 이진 탐색 트리이다

이진 탐색트리는 동적 자료구조이므로 삽입/삭제 연산과 함께 구조가 계속 변하게 되고 이는 성능에 영향을 준다.
균형이 맞지않는 트리는 최악의 경우 linked list 수준의 탐색 경로를 갖게된다.

따라서 트리의 균형을 유지하도록 만드는데, 만약 완전 균형을 유지하게 하려면 `O(n)`의 시간복잡도가 필요하다.

효율성을 위해 (거의) 완전한 균형 트리를 구성하는 여러 구현방식이 존재한다.
아래 방식의 경우 탐색/삽입/삭제 연산의 시간복잡도가 `O(logn)`이다.

### Splay 트리

Splay 트리는 자주 탐색하는 키를 가진 노드를 루트에 가깝게 위치하도록 구성한 BS 트리이다.
이 트리는 Splay 연산을 적용하여 최근에 접근한 노드를 루트에 위치시켜 트리를 재구성한다.

탐색/삽입/삭제 연산의 시간복잡도는 `amortized O(log n)`이다.

#### Splay 연산

Splay(x) 연산은 임의의 노드 x를 루트로 만드는 연산이다.

Rotate(x) 연산은 x를 x의 부모위치로 올리는 연산이다.

> 최근에 접근한 노드(x), x의 부모노드(p), x의 조부모노드(g)

- x가 루트이면 종료한다
- x의 부모 p가 루트이면 Rotate(x) 실행후 종료: **Zig**
- x의 조부모가 g인경우
  - g -> p의 방향과 p -> x의 방향이 같으면, Rotate(p) -> Rotate(x) 실행: **Zig-Zig**
  - g -> p의 방향과 p -> x의 방향이 다르면, Rotate(x)를 두변 실행: **Zig-Zag**
- x가 루트가 될때까지 반복한다

```go
func Splay(x *node) {
    for x.p != nil {
        p := x.p
        g := p.p
        if g != nil {
          if (x == p.left) == (p == g.left) {
            Rotate(p)
          } else {
            Rotate(x)
          }
        }
        Rotate(x);
    }
}
```

#### Zig / Zig-Zig / Zig-Zag

- Zig
  - p가 트리의 루트이면 p와 x의 간선연결(edge joining)을 회전시킨다
- Zig-Zig
  - p가 루트가 아니고 x와 p가 동일한 방향의 왼쪽(오른쪽) 자식인경우
  - p와 조부모 g와의 간선연결을 회전시키고(`Rotate(p)`)
  - x와 p의 간선연결을 회전시킨다(`Rotate(x)`)
- Zig-Zag
  - p가 루트가 아니고 x가 왼쪽(오른쪽)자식, p가 오른쪽(왼쪽) 자식인경우
  - x와 p의 간선 연결을 회전시키고(`Rotate(x)`)
  - x와 x의 새로운 부모 p와의 간선 연결을 회전시킨다(`Rotate(x)`)

#### Rotate(x)

대상 `x`, 부모 `p`, 회전방향과 같은쪽 `x`의 자식 `b`

- p의 회전방향 반대쪽 자식으로 b를 지정
- x의 회전방향 쪽 자식으로 p를 지정
- x의 부모로 p의 부모 지정
- p의 부모로 x를 지정
- b의 부모로 p를 지정
- p의 부모가 자식으로 가리키던 p를 x로 지정
  - p의 부모가 없다면(루트) tree 포인터에 x를 지정

```go
type node struct {
    left *node
    right *node
    p *node
}

func Rotate(x *node) {
    p := x.p
    var b *node;
    if x == p.left {
        b = x.right
        p.left = b
        x.right = p
    } else {
        b = x.left
        p.right = b
        x.left = p
    }
    x.p = p.p
    p.p = x
    if b != nil {
        b.p = p
    }

    if x.p != nil {
      var pp *node
      if p == x.p.left {
        pp = x.p.left
      } else {
        pp = x.p.right
      }
      pp = x
    } else {
      tree = x
    }
}
```

### AVL 트리

노드의 삽입과 삭제가 일어날 때 노드 키 값과 서브트리 키값 사이의 관계를 유지하며 균형을 만들기는 쉽지않다.

BS 트리의 탐색 성능을 개선하면서 균형을 유지하는데 따르는 수고를 줄이려면
제한조건을 완화하여 트리가 (완전한) 균형이 아닌것을 허용해야 한다.

AVL 트리는 거의 완전한 균형 트리의 한 형태로 높이가 균형잡힌 높이 균형트리이다.

트리의 각 노드 Vi에 대해서 다음과 같은 성질을 만족할 때 그 트리는 높이가 균형 잡힌 트리이다.

> 노드 Vi의 왼쪽 서브트리 높이와 Vi의 오른쪽 서브트리 높이가 최대 1만큼 차이난다

AVL 트리는 직접 탐색 성능이 좋다. 비록 완전히 균형 잡히지는 않았지만 탐색 경로의 길이는 거의 차이가 없다.
만일 삽입이나 삭제 수행이 AVL 트리의 균형을 깨면 트리를 균형잡힌 상태로 재구성하는데 이를 rotation이라 한다.

### BB((Weight-balanced) 트리

거의 완전히 균형 잡힌 트리의 다른 종류로 무게가 균형잡힌 트리가 있다.
이 트리를 무게 균형트리 또는 BB 트리라고 한다.

무게 균형트리는 양쪽 서브트리 무게가 균형을 유지하는 트리이다.
즉, 임의의 노드 x에 대해 다음식이 만족하도록 트리를 구성한다

`sqrt(2) - 1 < 왼쪽 서브트리 무게 / 오른쪽 서브트리 무게 < sqrt(2) + 1`

BB 트리의 경우 서브트리 높이가 아닌 서브트리 노드 개수에 제한을 둔 것이다.

BB 트리의 평균 탐색 길이 역시 균형트리와 크게 차이나지 않는다.
또한 삽입이나 삭제에 의해 균형을 잃으면 rotation 연산을 통해 균형을 유지한다.
